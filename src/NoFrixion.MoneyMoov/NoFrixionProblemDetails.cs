//-----------------------------------------------------------------------------
// Filename: NoFrixionProblemDetails.cs
//
// Description: Based on the ASP.NET Core ProbelmDetails class. Provides a
// standard way to deliver API error information to callers.
//
// Author(s):
// Aaron Clauson (aaron@nofrixion.com)
// 
// History:
// 26 Nov 2022  Aaron Clauson   Created, Stillorgan Wood, Dublin, Ireland.
//
// License: 
// MIT.
//-----------------------------------------------------------------------------

using System.Collections;
using System.Net;
using System.Text.Json.Serialization;

namespace NoFrixion.MoneyMoov;

/// <summary>
/// Taken from ASP.NET Core MVC ProblemDetailsDefaults class. Using the same values for consistency.
/// </summary>
internal static class ProblemDetailsDefaults
{
    public static readonly Dictionary<int, (string Type, string Title)> Defaults = new()
    {
        [400] =
        (
            "https://tools.ietf.org/html/rfc7231#section-6.5.1",
            "Bad Request"
        ),

        [401] =
        (
            "https://tools.ietf.org/html/rfc7235#section-3.1",
            "Unauthorized"
        ),

        [403] =
        (
            "https://tools.ietf.org/html/rfc7231#section-6.5.3",
            "Forbidden"
        ),

        [404] =
        (
            "https://tools.ietf.org/html/rfc7231#section-6.5.4",
            "Not Found"
        ),

        [406] =
        (
            "https://tools.ietf.org/html/rfc7231#section-6.5.6",
            "Not Acceptable"
        ),

        [409] =
        (
            "https://tools.ietf.org/html/rfc7231#section-6.5.8",
            "Conflict"
        ),

        // This response code is being used to indicate an operation, such as sending an HTTP request,
        // did not occur as there was a problem before it could be attempted.
        [412] =
        (
            "https://tools.ietf.org/html/rfc7232#section-4.2",
            "Precondition Failed"
        ),

        [415] =
        (
            "https://tools.ietf.org/html/rfc7231#section-6.5.13",
            "Unsupported Media Type"
        ),

        [422] =
        (
            "https://tools.ietf.org/html/rfc4918#section-11.2",
            "Unprocessable Entity"
        ),

        [500] =
        (
            "https://tools.ietf.org/html/rfc7231#section-6.6.1",
            "An error occurred while processing your request."
        ),
    };
}

//
// Summary:
//     A machine-readable format for specifying errors in HTTP API responses based on
//     https://tools.ietf.org/html/rfc7807.
//[JsonConverter(typeof(ProblemDetailsJsonConverter))]
public class NoFrixionProblemDetails
{
    public static NoFrixionProblemDetails Empty = new NoFrixionProblemDetails { _isEmpty = true };
    private bool _isEmpty = false;

    //
    // Summary:
    //     A URI reference [RFC3986] that identifies the problem type. This specification
    //     encourages that, when dereferenced, it provide human-readable documentation for
    //     the problem type (e.g., using HTML [W3C.REC-html5-20141028]). When this member
    //     is not present, its value is assumed to be "about:blank".
    [JsonPropertyName("type")]
    public string Type { get; set; } = ProblemDetailsDefaults.Defaults[(int)HttpStatusCode.BadRequest].Type;

    //
    // Summary:
    //     A short, human-readable summary of the problem type.It SHOULD NOT change from
    //     occurrence to occurrence of the problem, except for purposes of localization(e.g.,
    //     using proactive content negotiation; see[RFC7231], Section 3.4).
    [JsonPropertyName("title")]
    public string Title { get; set; } = ProblemDetailsDefaults.Defaults[(int)HttpStatusCode.BadRequest].Title;
    //
    // Summary:
    //     The HTTP status code([RFC7231], Section 6) generated by the origin server for
    //     this occurrence of the problem.
    [JsonPropertyName("status")]
    public int Status { get; set; }
    //
    // Summary:
    //     A human-readable explanation specific to this occurrence of the problem.
    [JsonPropertyName("detail")]
    public string Detail { get; set; } = string.Empty;
    //
    // Summary:
    //     A URI reference that identifies the specific occurrence of the problem.It may
    //     or may not yield further information if dereferenced.
    [JsonPropertyName("instance")]
    public string Instance { get; set; } = string.Empty;

    [JsonIgnore]
    public string RawError { get; set; } = string.Empty;

    //
    // Summary:
    //     Gets the System.Collections.Generic.IDictionary`2 for extension members.
    //     Problem type definitions MAY extend the problem details object with additional
    //     members. Extension members appear in the same namespace as other members of a
    //     problem type.
    //
    // Remarks:
    //     The round-tripping behavior for Microsoft.AspNetCore.Mvc.ProblemDetails.Extensions
    //     is determined by the implementation of the Input \ Output formatters. In particular,
    //     complex types or collection types may not round-trip to the original type when
    //     using the built-in JSON or XML formatters.
    [JsonExtensionData]
    public IDictionary<string, object?>? Extensions { get; set; }

    public IDictionary<string, List<string>>? Errors { get; set; }

    public bool IsEmpty => _isEmpty;

    private NoFrixionProblemDetails()
    { }

    public NoFrixionProblemDetails(HttpStatusCode status, string error)
    {
        Status = (int)status;

        if (ProblemDetailsDefaults.Defaults.ContainsKey((int)status))
        {
            Title = ProblemDetailsDefaults.Defaults[(int)status].Title;
            Type = ProblemDetailsDefaults.Defaults[(int)status].Type;
        }

        Detail = error;
    }

    public string ToJson() =>
        System.Text.Json.JsonSerializer.Serialize(this);

    public string ToErrorMessage()
    {
        string error = string.Empty;

        if (Status != 0)
        {
            error = $"Error Status Code {Status}";
        }

        if (!string.IsNullOrEmpty(Title))
        {
            error += ": " + Title;
        }

        if (!string.IsNullOrEmpty(Detail))
        {
            error += ". " + Detail;
        }

        if (Extensions?.Count > 0)
        {
            error += " Validation errors: ";

            foreach (var kvp in Extensions)
            {
                if (kvp.Value is IEnumerable)
                {
                    error += kvp.Key + ": ";

                    foreach (var item in (kvp.Value as IEnumerable)!)
                    {
                        error += item.ToString() + ", ";
                    }
                }
                else
                {
                    error += $"{kvp.Key}: {kvp.Value?.ToString()}, ";
                }
            }
        }

        if (Errors?.Count > 0)
        {
            error += " Validation errors: ";

            foreach (var kvp in Errors)
            {
                if (kvp.Value is IEnumerable)
                {
                    error += kvp.Key + ": ";

                    foreach (var item in (kvp.Value as IEnumerable)!)
                    {
                        error += item.ToString() + ", ";
                    }
                }
                else
                {
                    error += $"{kvp.Key}: {kvp.Value?.ToString()}, ";
                }
            }
        }


        error += ".";

        //error += RawError;

        return error;
    }

    public string ToHtmlErrorMessage()
    {
        string htmlError = string.Empty;

        if (!string.IsNullOrEmpty(Title))
        {
            htmlError = $"<p><strong>{Title}</strong></p>";
        }

        if (!string.IsNullOrEmpty(Detail))
        {
            htmlError += $"<p>{Detail}</p>";
        }

        if (Extensions?.Count > 0)
        {
            htmlError += "<ul>";

            foreach (var kvp in Extensions)
            {
                if (kvp.Value is IEnumerable)
                {
                    htmlError += $"<li>{kvp.Key}<ul>";

                    foreach (var item in (kvp.Value as IEnumerable)!)
                    {
                        htmlError += item.ToString();
                    }

                    htmlError += $"</ul></li>";
                }
                else
                {
                    htmlError += $"<li>{kvp.Key}: {kvp.Value?.ToString()}</li>";
                }
            }

            htmlError += "</ul>";
        }

        return htmlError;
    }
}
